      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        toggleTask();
      }
    });

    contentDiv.addEventListener('click', e => e.stopPropagation());

    submitBtn.addEventListener('click', () => this.handleSubmit(task, feedbackP, submitBtn));

    contentDiv.querySelectorAll('input').forEach(input => {
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          this.handleSubmit(task, feedbackP, submitBtn);
        }
      });
    });
  }

  isTaskLocked(task, index) {
    return index > 0 && !this.completedTasks[tasks[index - 1]?.id];
  }

  showQuestionHint(task, questionIndex, hintText, hintBtn) {
    if (!task.hints || !task.hints[questionIndex]) return;
    
    // Initialize question attempts if not exists
    const questionKey = `${task.id}_q${questionIndex}`;
    if (!this.questionAttempts[questionKey]) {
      this.questionAttempts[questionKey] = 0;
    }
    
    const attemptCount = this.questionAttempts[questionKey];
    const availableHints = task.hints[questionIndex];
    const hintIndex = Math.min(attemptCount, availableHints.length - 1);
    
    if (hintText.style.display === 'block') {
      hintText.style.display = 'none';
      hintBtn.textContent = 'Hint';
    } else {
      // Increment hint counter
      this.hintClickCount++;
      this.taskHintsUsed[task.id]++;
      this.saveHintCount();
      this.updateHintCounter();
      
      // Check for hint achievements
      console.log('Checking hint achievements, hint count:', this.hintClickCount);
      checkAchievements('hint_used', { hintCount: this.hintClickCount });
      
      hintText.textContent = availableHints[hintIndex];
      hintText.style.display = 'block';
      hintBtn.textContent = 'Hide';
    }
  }

  async handleSubmit(task, feedbackP, submitBtn) {
    const inputs = Array.from(document.querySelectorAll(`input[id^="${task.id}_q"]`));
    const answers = inputs.map(inp => sanitizeInput(inp.value));

    if (answers.some(answer => !answer)) {
      this.showFeedback(feedbackP, 'Please fill in all fields.', 'error');
      return;
    }

    submitBtn.disabled = true;
    submitBtn.classList.add('loading');
    submitBtn.textContent = '';

    try {
      // Call Val.town API for validation
      const response = await fetch(CONFIG.VAL_TOWN_API, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          taskId: task.id, 
          answers: answers,
          userId: currentUser?.id || 'anonymous'
        })
      });

      if (!response.ok) {
        throw new Error('Validation failed');
      }

      const result = await response.json();
      const allCorrect = result.allCorrect;
      
      if (allCorrect) {
        if (this.completedTasks[task.id]) {
          this.showFeedback(feedbackP, 'Task already completed! 🎉', 'info');
        } else {
          this.completedTasks[task.id] = {
            completed: true,
            timestamp: new Date().toISOString(),
            attempts: (this.attemptCounts[task.id] || 0) + 1
          };
          this.saveProgress();
          this.showFeedback(feedbackP, 'Correct! Task completed! 🎉', 'success');
          this.launchFireworks();
          this.updateTaskStatus(task.id);
          this.updateProgress();
          this.unlockNextTask(task);
          
          // Check for task completion achievements
          const taskHintsUsed = this.taskHintsUsed[task.id] || 0;
          checkAchievements('task_completed', { 
            taskId: task.id, 
            completedCount: Object.keys(this.completedTasks).length,
            attempts: this.attemptCounts[task.id] || 1,
            hintsUsed: this.hintClickCount,
            taskHintsUsed: taskHintsUsed
          });
          
          // Update Firebase with TOTAL hints count
          if (currentUser) {
            await updateUserProgress(
              currentUser.id,
              task.id,
              true,
              this.hintClickCount,  // Pass the TOTAL hints used so far
              this.attemptCounts[task.id] || 1
            );
          }
        }
      } else {
        // Increment attempt counts for incorrect questions
        result.results.forEach((correct, index) => {
          if (!correct) {
            const questionKey = `${task.id}_q${index}`;
            this.questionAttempts[questionKey] = (this.questionAttempts[questionKey] || 0) + 1;
          }
        });
        
        this.attemptCounts[task.id] = (this.attemptCounts[task.id] || 0) + 1;
        
        const incorrectCount = result.results.filter(r => !r).length;
        this.showFeedback(feedbackP, `${incorrectCount} answer(s) incorrect. Check the hints for help!`, 'error');
        
        // Track wrong answers for achievements
        checkAchievements('answer_wrong', { wrongCount: incorrectCount });
      }
    } catch (error) {
      this.showFeedback(feedbackP, 'An error occurred. Please try again.', 'error');
      console.error('Validation error:', error);
    } finally {
      setTimeout(() => {
        submitBtn.disabled = false;
        submitBtn.classList.remove('loading');
        submitBtn.textContent = 'Submit';
      }, 1000);
    }
  }

  showFeedback(feedbackEl, message, type) {
    feedbackEl.textContent = message;
    feedbackEl.className = `feedback ${type}`;
  }

  updateTaskStatus(taskId) {
    const taskEl = document.querySelector(`[data-task-id="${taskId}"]`);
    if (taskEl) {
      taskEl.classList.add('completed');
      const badge = taskEl.querySelector('.task-badge');
      badge.textContent = 'Completed';
      badge.classList.add('completed');
    }
  }

  unlockNextTask(currentTask) {
    const currentIndex = tasks.findIndex(t => t.id === currentTask.id);
    if (currentIndex < tasks.length - 1) {
      const nextTask = tasks[currentIndex + 1];
      const nextTaskEl = document.querySelector(`[data-task-id="${nextTask.id}"]`);
      if (nextTaskEl) {
        nextTaskEl.style.display = 'list-item';
        nextTaskEl.classList.remove('locked');
        const badge = nextTaskEl.querySelector('.task-badge');
        badge.textContent = 'Available';
        badge.classList.remove('locked');
      }
    }

    tasks.forEach(task => {
      if (task.hiddenUntil === currentTask.id) {
        const hiddenTaskEl = document.querySelector(`[data-task-id="${task.id}"]`);
        if (hiddenTaskEl) {
          hiddenTaskEl.style.display = 'list-item';
          hiddenTaskEl.classList.add('bonus');
        }
      }
    });
  }

  launchFireworks() {
    const canvas = document.getElementById('fireworks');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const particles = Array.from({ length: CONFIG.FIREWORKS_PARTICLES }, () => ({
      x: canvas.width / 2 + (Math.random() - 0.5) * 200,
      y: canvas.height / 2 + (Math.random() - 0.5) * 200,
      radius: Math.random() * 4 + 1,
      color: `hsl(${Math.random() * 360}, 100%, 60%)`,
      angle: Math.random() * 2 * Math.PI,
      speed: Math.random() * 8 + 3,
      alpha: 1,
      decay: 0.015 + Math.random() * 0.02,
      gravity: 0.1
    }));

    function animate() {
      ctx.fillStyle = 'rgba(0,0,0,0.1)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      particles.forEach((particle, index) => {
        particle.x += Math.cos(particle.angle) * particle.speed;
        particle.y += Math.sin(particle.angle) * particle.speed + particle.gravity;
        particle.speed *= 0.99;
        particle.alpha -= particle.decay;
        particle.gravity += 0.02;

        if (particle.alpha <= 0) {
          particles.splice(index, 1);
          return;
        }

        ctx.save();
        ctx.globalAlpha = particle.alpha;
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.radius, 0, 2 * Math.PI);
        ctx.fillStyle = particle.color;
        ctx.fill();
        ctx.restore();
      });

      if (particles.length > 0) {
        requestAnimationFrame(animate);
      } else {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    }

    animate();
    
    setTimeout(() => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }, CONFIG.ANIMATION_DURATION);
  }
}

window.addEventListener('resize', () => {
  const canvas = document.getElementById('fireworks');
  if (canvas) {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    document.querySelectorAll('li.task.open').forEach(li => {
      li.classList.remove('open');
      li.querySelector('.task-content').style.display = 'none';
    });
  }
});

setInterval(() => {
  if (tasks.length !== 6) {
    console.warn('Task integrity compromised');
  }
}, 5000);

console.log(`
  ╔═══════════════════════════════════╗
  ║        OSINT Challenge            ║
  ║                                   ║
  ║   Looking for shortcuts? 🕵️       ║
  ║   That's not very OSINT of you!   ║
  ║                                   ║
  ║   Happy investigating! 🔍         ║
  ╚═══════════════════════════════════╝
`);

</script>

</body>
</html>
